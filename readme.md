# 简要介绍

这个项目是在LX（公司）的时候，老板提出要做（抄）的东西。

**期望实现"无需代码变更，配置化实现业务需求"。**

参考了10+厂商的系统，总结大概3个思路

    1，第一种思路是挂羊头卖狗肉
    
    把N个功能模块（例如账务，交易，请结算，计费……）的聚合（单点登录？）
    在一个集中化 的平台管理，重新起个名字“产品工厂”
    
    这个是比例最大的。大概占据了50%

    2，第二种思路是低代码
    一般是提供了2套组件：可视化表单编辑，流程编排。
    
    这种，只能普通OA,或者CMS希望玩玩，做不了复杂的业务。
    
    3，第三种思路是特化apollo
    
    这种严格意义上来讲不是一种思路，只是算情况1的技术优化————用apollo作为
    基础设施来承接情况1的存储层和接口u层，UI重新开发。
    
    ————利用了apollo的动态发布和sdk无服务器启动能力（算不上什么有意义的方案）
    
    


分析下来，这三种思路没有一个能解决我们的需求

    1，技术债的根本在应用，而不在配置层。是应用技术债太重，而不是配不出来
        
        1.1 配置平台无论再怎么改，再怎么拖拉拽，花里胡哨，应用这边不支持没用。
        1.2 各种配置可视化平台，本质上是把配置人员从开发转为业务，而且只是针对部分场景，
            复杂的场景，还是需要开发支持。实际情况演化下来很可能还是业务张嘴，开发动手   
            解决不了根本问题
    
    2，不能说没有价值，探讨下来最大的价值在于
        
        2.1  给产品提供一个定义产品要素的平台，模型参数和技术实现无关（即构建领域模型）
        2.2  在存在领域模型的基础上，应用架构的实际问题转变为一个对特定模型DSL的解析和执行的过程
                分为两个部分
                2.2.1 流程的部分，应用自己解决，领域模型不care的。
                2.2.2 逻辑的部分，能完整给出一个清晰的视图，确保后续的配置化是可靠的。
    
    3，仅此而已，如果只是这样效果很寥寥
    
        从建行的经验看https://max.book118.com/html/2018/0303/155601577.shtm
    
        即使建成
    
        3.1，只不支持突破性的创新，仅支持产品模型定义的那几种变化
                
    
    
    **4，我认为真正可行的思路
        
        既然问题的关键在应用，而不在产品工厂，所以我的思路基本不以产品工厂为核心，而只是聚焦于应用的问题
    
        应用架构在技术上可以抽象为两部分
    
        4.1 流程的变化
        4.2 流程上业务逻辑的变化。
    
        流程的变化，流程编排组件可以搞定。支持配置化新增，变更流程上任意节点，对上下游无影响。
    
        对于流程上action的变化，原则上
        4.2.1 靠堆人来应对变化，原则上已经完全解耦了，风险和工作量是可控的。
        4.2.2 如果幸运的话，能归纳抽象出通用的业务组件，例如计费、权益、合同……
            这些并不关键，只是局部效率的提升。
        
        这样下来，原则上应用系统技术债应该可以被消弥大部分
            a，业务线是清晰的
            b，业务变化是可控的
            c，有效率提升的主动性和机会**
    
    5，产品工厂在哪？
        
        其实，各种分析下来，感觉没有什么特别有价值。 
        
        自从05年IBM鼓吹这个概念来，所以到现在没有看到很好的实践。
    
        所以，这个项目做了一半我也想废弃了。
    
    6，但也有一些特别之处（好玩的地方）
    
        我们采用的是方案3（特化apollo）
        6.1 我们重写了一个更好的apollo
        6.2 不过没有直接服用apollo的代码，他代码太冗余了
            6.2.1 他绑定了eureka，我采用的方式类似spring-cloud，定义接口而不实现，通过starter扩展适配
            6.2.2 代码上耦合了servlet协议，我采用的方式是接口开发，原因同上
            6.3.3 IOC上他使用了Guice，我采用的是向下IOC（依赖注入JVM容器），引入的组件更少
            6.3.4 元数据页面插件化解耦，可灵活扩展。

        所以基本上，用1/100甚至更少的代码实现了更好的扩展性和清晰度。
        ……
        
        上面都是一些技术的玩意，有意思也没意思（在业务看起来没有价值，但是比较容易适配各种基础设施）
    
        在业务上的创新是
        6.3 采用了产品，要素，能力，组件的四级抽象
        6.4 提供组合策略，实现能力可组合式扩展
        6.5 提供了schema来规范应用代码实现，通过产品工厂提升应用质量
        6.6 提供了副作用视图机制，通过产品工厂提供业务能力关系和路由视图，帮助产品针对性创新
    

![img.png](img.png)

![img_1.png](img_1.png)

![img_2.png](img_2.png)

# 模块和分包介绍

    pf-admin    //前台页面
        matadata        //元数据管理
        publish         //发布管理
        approve         //审批平台集成
        
    pf-admin    //产品增删改，发布流程审批等
        
    pf-server   //产品配置服务平台（高可用，高性能）
        
    pf-sdk      //配置推拉，无服务器启动
        sdk
            localRepository //本地存储
    pf-api      //接口 通用包
        schema      //产品要素schema定义
        function    //组合函数定义
        metadata    //元数据源定义
        api         //元数据源定义
            client、server、admin 接口定义

    

# 